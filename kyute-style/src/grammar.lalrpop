use crate::ast::*;
use crate::color::Color;
use crate::ParseState;

grammar<'ast, 'state>(state: &'state mut ParseState<'ast>);


///////////////////////////////////////////////////////////////////////
// Macros
///////////////////////////////////////////////////////////////////////
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

newline<T>: Vec<T> = {
              <v:(<T> ",")*> <e:T?> => match e {
                  None => v,
                  Some(e) => {
                      let mut v = v;
                      v.push(e);
                      v
                  }
              }
          };

ValueOrVar<T>: ValueOrVar<'ast, T> = {
    <VarRef> => ValueOrVar::Var(<>),
    <T> => ValueOrVar::Value(<>),
};


///////////////////////////////////////////////////////////////////////
// Document & Items
///////////////////////////////////////////////////////////////////////
pub Document: Document<'ast> = {
    <Item*> => Document { items: state.arena.alloc_slice_copy(&<>) }
};

Item: Item<'ast> = {
    <name:Identifier> ":" <value:Expr> ";" => Item { name, value },
    <name:Identifier> ":" <record:Record> => Item { name, value: Expr::Record(state.arena.alloc(record)) },
    //<name:Identifier> <record:Record> => Item { name, record }
    //<ItemColor> ";" => Item::Color(state.arena.alloc(<>)),
    //<ItemBorder> ";" => Item::Border(state.arena.alloc(<>)),
    //<ItemPaint> ";" => Item::Paint(state.arena.alloc(<>)),
};

Expr: Expr<'ast> = {
    <ColorExpr> => { Expr::Color(state.arena.alloc(<>)) },
    <HexColor> => { Expr::Color(state.arena.alloc(ColorExpr { color: ValueOrVar::Value(Color::from_hex(<>).unwrap()) })) },
    <LinearGradientExpr> => { Expr::LinearGradient(state.arena.alloc(<>)) },
    <BorderExpr> => { Expr::Border(state.arena.alloc(<>)) },
    <VarRef> => { Expr::Var(<>) },
};

///////////////////////////////////////////////////////////////////////
// Linear gradient
///////////////////////////////////////////////////////////////////////
pub LinearGradientExpr : LinearGradientExpr<'ast> = {
    "linear-gradient" "(" <orientation:(<Dimension> ",")?> <stops:Comma<GradientStop>> ")" => {
        LinearGradientExpr {
            orientation: orientation.unwrap_or(Dimension { value: 0.0, unit: Unit::Degrees }),
            stops: state.arena.alloc_slice_copy(&stops)
        }
    }
};

pub GradientStop : GradientStop<'ast> = {
    <color:ValueOrVar<Color>> => GradientStop {
        color,
        pos1: None,
        pos2: None
    },
    <color:ValueOrVar<Color>> <pos1:Dimension> => GradientStop {
        color,
        pos1: Some(pos1),
        pos2: None
    },
    <color:ValueOrVar<Color>> <pos1:Dimension> <pos2:Dimension> => GradientStop {
        color,
        pos1: Some(pos1),
        pos2: Some(pos2)
    }
};

///////////////////////////////////////////////////////////////////////
// Colors
///////////////////////////////////////////////////////////////////////

ColorExpr: ColorExpr<'ast> = { "color" "(" <color:ValueOrVar<Color>> ")" => ColorExpr { color } };
Color: Color = { <HexColor> => Color::from_hex(<>).unwrap() };

///////////////////////////////////////////////////////////////////////
// Borders
///////////////////////////////////////////////////////////////////////

BorderExpr : BorderExpr<'ast> = {
    "border" "(" <border:ValueOrVar<Border>> ")" => BorderExpr { border }
};

Border : Border<'ast> = {
    <length:ValueOrVar<Dimension>> <position:BorderPosition?> <color:ValueOrVar<Color>> => Border { position: position.unwrap_or_default(), length, color }
};

BorderPosition : BorderPosition = {
    "inside" => BorderPosition::Inside,
    "outside" => BorderPosition::Outside,
    "center" => BorderPosition::Center,
};

///////////////////////////////////////////////////////////////////////
// Records
///////////////////////////////////////////////////////////////////////
Record : RecordExpr<'ast> = {
    <class:RecordClass?> "{"
        <attributes:Item*>
    "}" => RecordExpr { class, attributes: state.arena.alloc_slice_copy(&attributes) }
};

RecordClass : &'ast str = { "[" <Identifier> "]" }

///////////////////////////////////////////////////////////////////////
// Terminals
///////////////////////////////////////////////////////////////////////
Identifier: &'ast str = { IdentifierT => state.arena.alloc_str(<>) };
VarRef: &'ast str = { VarRefT => state.arena.alloc_str(<>) };

HexColor: &'ast str = {
    HexColor4T => state.arena.alloc_str(<>),
    HexColor3T => state.arena.alloc_str(<>),
 };

Dimension: Dimension = {
    DimensionDegT => Dimension { value: <>.strip_suffix("deg").unwrap().parse().unwrap(), unit: Unit::Degrees },
    DimensionDipT => Dimension { value: <>.strip_suffix("dip").unwrap().parse().unwrap(), unit: Unit::Dip },
    DimensionEmT => Dimension { value: <>.strip_suffix("em").unwrap().parse().unwrap(), unit: Unit::Em },
    DimensionPxT => Dimension { value: <>.strip_suffix("px").unwrap().parse().unwrap(), unit: Unit::Px },
    DimensionInT => Dimension { value: <>.strip_suffix("in").unwrap().parse().unwrap(), unit: Unit::In },
    DimensionPercentageT => Dimension { value: <>.strip_suffix("%").unwrap().parse().unwrap(), unit: Unit::Percentage },
}

Number: f64 = { NumberT => <>.parse().unwrap(), };

match {
    ";" => ";",
    ":" => ":",
    "linear-gradient" => "linear-gradient",
    "paint" => "paint",
    "inside" => "inside",
    "outside" => "outside",
    "center" => "center",
    "border" => "border",
    "color" => "color",
    "(" => "(",
    ")" => ")",
    "{" => "{",
    "}" => "}",
    "[" => "[",
    "]" => "]",
    "," => ",",
    r"[a-zA-Z_][a-zA-Z0-9_\-]*" => IdentifierT,
    r"\$[a-zA-Z_\-][a-zA-Z0-9_\-]*" => VarRefT,
    r"#(?:[0-9a-fA-F]{4}){1,2}" => HexColor4T,
    r"#(?:[0-9a-fA-F]{3}){1,2}" => HexColor3T,
    r"[+-]?[0-9]*[.]?[0-9]+(?:[eE][+-]?[0-9]+)?" => NumberT,
    r"[+-]?[0-9]*[.]?[0-9]+(?:[eE][+-]?[0-9]+)?deg" => DimensionDegT,
    r"[+-]?[0-9]*[.]?[0-9]+(?:[eE][+-]?[0-9]+)?dip" => DimensionDipT,
    r"[+-]?[0-9]*[.]?[0-9]+(?:[eE][+-]?[0-9]+)?em" => DimensionEmT,
    r"[+-]?[0-9]*[.]?[0-9]+(?:[eE][+-]?[0-9]+)?px" => DimensionPxT,
    r"[+-]?[0-9]*[.]?[0-9]+(?:[eE][+-]?[0-9]+)?in" => DimensionInT,
    r"[+-]?[0-9]*[.]?[0-9]+(?:[eE][+-]?[0-9]+)?%" => DimensionPercentageT,
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { },
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
}

